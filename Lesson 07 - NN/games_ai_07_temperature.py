# -*- coding: utf-8 -*-
"""Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UVq3FYqgjzEjhwfMHkA_Piy4p-FqG-oa

We will try to solve the conversion of Celsius degrees to Fahrenheit degrees.

Of course, it would be simple enough to create a conventional Python function that directly performs this calculation, but that wouldn't be machine learning (and certainly much less fun).

You should NEVER use this approach for this problem. However, it is great as an introductory problem - it is simple and understandable, and there is one little surprise on the way.

We will use TensorFlow, NumPy, and a plotting library.
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt

print(tf.version.VERSION)
print(np.version.version)

# to ensure reproducible results (good for testing, usually not good for production)
# RANDOM_SEED = 42

# np.random.seed(RANDOM_SEED)
# tf.random.set_seed(RANDOM_SEED)

# generate train data
celsius = np.array([-30, -25, -10, 0, 10, 20, 35, 50, 70, 100], dtype=np.float32)

# the right outputs for the train data
# (usually you will not calculate those in runtime, but they will be provided in the dataset)
fahrenheit = [t * 1.8 + 32 for t in celsius]
print(fahrenheit)

# needs to be a numpy array
fahrenheit = np.array(fahrenheit, dtype=np.float32)

print(celsius)
print(fahrenheit)

# the most basic NN - 1 layer with 1 neuron
# later experiment with more layers and more neurons
model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=[1]),
    tf.keras.layers.Dense(units=1),
])

# an alternative way of creating the model
# input_layer = tf.keras.layers.Input(shape=[1])
# l0 = tf.keras.layers.Dense(units=1)
# model = tf.keras.Sequential([input_layer, l0])

# NN with 2 layer and 3 neurons
# model = tf.keras.Sequential([
#   tf.keras.layers.Input(shape=[1]),
#   tf.keras.layers.Dense(units=2),
#   tf.keras.layers.Dense(units=1), # needs to be "1" because we expect only one value as output
# ])

# "loss" is the loss function
# optimizer will be explained in future lesson
# later experiment with MeanSquaredError (MSE) loss - it usually helps to achieve better results for this problem
model.compile(
    loss=tf.keras.losses.MeanAbsoluteError(),
    optimizer=tf.keras.optimizers.Adam(0.1)
)

# you can also use string values which will be converted to the corresponding objects with default values
# model.compile(
#     loss="mean_absolute_error",
#     optimizer="adam"
# )

# Summary of the network layers and its parameters
model.summary()

# randomly initialized weights (bias is zero)
print(model.layers[0].get_weights())

w = 0.14633286
b = 0
y = 20 * w + b
loss = abs(68 - y)
print(y)
print(loss)

# model.fit starts the training process with defined number of epochs
# verbose=False - the output is very long, and we have 500 epochs, experiment with value of True (which is default)
history = model.fit(x=celsius, y=fahrenheit, epochs=500, verbose=False)
print("Training finished")

plt.xlabel("Epoch Number")
plt.ylabel("Loss Value")
plt.plot(history.history["loss"])
# plt.plot(history.history["loss"][100:499])
plt.show()

# make sure this value was NOT in the training
celsius_test_value = 25
celsius_test_value = np.array([celsius_test_value], dtype=np.float32)
print("Predicted value:", model.predict(celsius_test_value))
print("Correct value:", celsius_test_value[0] * 1.8 + 32)

print("These are the neuron variables values:", model.layers[0].get_weights())

celsius_test = np.array([-45, -20, 5, 25, 40, 60])  # these values were NOT in the train set (very important!)
fahrenheit_true = np.array([t * 1.8 + 32 for t in celsius_test])
fahrenheit_predicted = np.array([])
error = []
# print(fahrenheit_true)

for i, c in enumerate(celsius_test):
    predicted = model.predict([np.array([c], dtype=np.float32)])
    error.append(abs(predicted - fahrenheit_true[i]))
    fahrenheit_predicted = np.append(fahrenheit_predicted, predicted)

print("Correct values:", fahrenheit_true)
print("Predicted values:", fahrenheit_predicted)
print()
print("Absolute error values:", error)
print("MAE:", np.average(error))

# MAE = |a - b|
# MSE = (a - b)^2

mae = tf.keras.losses.MeanAbsoluteError()
mae_val = mae(fahrenheit_true, fahrenheit_predicted).numpy()
print("MAE:", mae_val)

mse = tf.keras.losses.MeanSquaredError()
mse_val = mse(fahrenheit_true, fahrenheit_predicted).numpy()
print("MSE:", mse_val)